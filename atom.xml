<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Feng&#39;s Blog</title>
  
  <subtitle>从心所欲不逾矩。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://fenglee594.github.io/"/>
  <updated>2020-06-11T09:42:50.572Z</updated>
  <id>http://fenglee594.github.io/</id>
  
  <author>
    <name>Feng</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Objective-C 对象解读</title>
    <link href="http://fenglee594.github.io/2020/05/28/iOS%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%86%E7%B1%BB/"/>
    <id>http://fenglee594.github.io/2020/05/28/iOS%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%86%E7%B1%BB/</id>
    <published>2020-05-28T02:58:37.000Z</published>
    <updated>2020-06-11T09:42:50.572Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>写Blog也是一门技术啊,逻辑还是有点混乱…</p><h4 id="对象的分类"><a href="#对象的分类" class="headerlink" title="对象的分类"></a>对象的分类</h4><p>iOS对象分为以下三类</p><ul><li>实例对象(instance对象)</li><li>类对象(class对象)</li><li>元类对象(meta-class对象)<a id="more"></a></li></ul><h5 id="实例对象"><a href="#实例对象" class="headerlink" title="实例对象"></a>实例对象</h5><p>实例对象就是通过类alloc出来的对象，每次调用alloc都会产生新的instance对象<br>例如<code>NSObject *objc = [[NSObject alloc] init];</code><br>其中objc就是实例对象</p><p>实例对象中存储的信息包括</p><ul><li>isa指针</li><li>其他成员变量(isa也可以看作一个特殊的成员变量)</li></ul><h5 id="类对象"><a href="#类对象" class="headerlink" title="类对象"></a>类对象</h5><p>class对象是一个类的对象,每个类在内存中有且仅有一个类对象,类对象(元类对象也一样)在程序启动时就已经装载在内存中了.<br>获取类对象的方法有如下几种</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSObject</span> *object1 = [[<span class="built_in">NSObject</span> alloc] init];</span><br><span class="line"><span class="built_in">NSObject</span> *object2 = [[<span class="built_in">NSObject</span> alloc] init];</span><br><span class="line"></span><br><span class="line">Class objectClass1 = [object1 <span class="keyword">class</span>];   <span class="comment">//调用实例方法class</span></span><br><span class="line">Class objectClass2 = [object2 <span class="keyword">class</span>];   <span class="comment">//同上</span></span><br><span class="line">Class objectClass3 = object_getClass(object1);  <span class="comment">//使用runtime的object_getClass方法(传入一个实例对象)</span></span><br><span class="line">Class objectClass4 = object_getClass(object2);</span><br><span class="line">Class objectClass5 = [<span class="built_in">NSObject</span> <span class="keyword">class</span>];  <span class="comment">//调用类方法class</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%p %p %p %p %p"</span>,</span><br><span class="line">              objectClass1,</span><br><span class="line">              objectClass2,</span><br><span class="line">              objectClass3,</span><br><span class="line">              objectClass4,</span><br><span class="line">              objectClass5);</span><br></pre></td></tr></table></figure><p>打印结果如下图,我们可以看到地址都是一样的,这表明NSObject在内存中有且仅有一个类对象<br><img src="WeChat169539cf0dff79428234a43af54db574.png" alt="" title="打印结果"></p><p>类对象存储的信息有</p><ul><li>isa指针</li><li>superclass指针</li><li>类的属性信息(@property)、类的实例方法信息(instance method)</li><li>类的协议信息(protocol)、类的成员变量信息(不包括成员变量的值) 等等其他</li></ul><h5 id="元类对象"><a href="#元类对象" class="headerlink" title="元类对象"></a>元类对象</h5><p>meta-class是用来描述类对象的类.每个类都有自己对应的元类对象<br>获取元类对象的方法是将类对象传到object_getClass()方法中获取的参考类对象的代码我们可以<br><code>Class metaClass = object_getClass(objectClass1)</code><br>这样获取,metaClass就是NSObject的元类对象.</p><p>元类对象中存储的信息</p><ul><li>isa指针</li><li>superclass指针</li><li>类方法信息</li></ul><h4 id="isa和superclass的指向"><a href="#isa和superclass的指向" class="headerlink" title="isa和superclass的指向"></a>isa和superclass的指向</h4><p><img src="WeChat8ee94ffee69c1dc59b49ab84c1a7607b.png" alt="" title="关系图"><br>上面这张图可以完美解释isa和superclass在实例对象、类对象和元类对象中的作用<br>总结一下有以下几点</p><ul><li>instance的isa指向class<br>class的isa指向meta-class<br>meta-class的isa指向基类的meta-class</li><li>class的superclass指向父类的class<br>如果没有父类,superclass指针为nil</li><li>meta-class的superclass指向父类的meta-class   基类meta-class的superclass指向基类的class</li><li>instance调用实例方法的轨迹<br>通过isa找到class对象,方法不存在,就通过superclass找父类</li><li>class调用类方法的轨迹<br>通过isa找到meta-class对象,方法不存在,就通过superclass找父类</li></ul><p>总之可以看出,调用方法时,首先你要搞清楚方法是在哪里(实例方法是存储在类对象里面,类方法是存储在元类对象里面),然后通过isa找到对应的对象,找不到就再通过superclass去父类里面找.isa-&gt;superclass-&gt;…-&gt;superclass=nil,如果最终还是找不到就会报经典错误unrecognized selector sent to xxx.</p><p>注意一点,在64位的环境下,instance对象的isa并不是直接指向类对象的,他会通过一次&amp;位运算才能计算出真实的类对象地址instance-&gt;isa &amp; ISA_MASK = class对象的内存地址,ISA_MASK的值可以在objc源码中找到.</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">if</span> __arm64__</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> ISA_MASK        0x0000000ffffffff8ULL</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">elif</span> __x86_64__</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> ISA_MASK        0x00007ffffffffff8ULL</span></span><br></pre></td></tr></table></figure><p>但superclass指针则是直接指向父类对象的真实地址</p><h4 id="Class的结构"><a href="#Class的结构" class="headerlink" title="Class的结构"></a>Class的结构</h4><p>我们在Xcode上追踪Class的结构可以看到<br><code>typedef struct objc_class *Class;</code><br>再追踪进去看objc_class的结构,发现是这样的</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> objc_class &#123;</span><br><span class="line">    Class _Nonnull isa  OBJC_ISA_AVAILABILITY;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !__OBJC2__</span></span><br><span class="line">    Class _Nullable super_class                              OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> * _Nonnull name                               OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">long</span> version                                             OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">long</span> info                                                OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">long</span> instance_size                                       OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">struct</span> objc_ivar_list * _Nullable ivars                  OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">struct</span> objc_method_list * _Nullable * _Nullable methodLists                    OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">struct</span> objc_cache * _Nonnull cache                       OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">struct</span> objc_protocol_list * _Nullable protocols          OBJC2_UNAVAILABLE;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">&#125; OBJC2_UNAVAILABLE;</span><br></pre></td></tr></table></figure><p>这表明在OC2.0里面objc_class的结构体里只有一个isa指针,下面的都已经过时了,这时候我们需要去<a href="https://opensource.apple.com/tarballs/objc4/" target="_blank" rel="noopener">objc</a>的源码工程里面去找了,找到以下代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_class</span> :</span> objc_object &#123;</span><br><span class="line">    <span class="comment">// ISA占8位</span></span><br><span class="line">    <span class="comment">// Class ISA;</span></span><br><span class="line">    <span class="comment">// superclass占8位</span></span><br><span class="line">    Class superclass;</span><br><span class="line">    <span class="comment">// 缓存的是指针和vtable,目的是加速方法的调用  cache占16位</span></span><br><span class="line">    <span class="keyword">cache_t</span> cache;             <span class="comment">// formerly cache pointer and vtable</span></span><br><span class="line">    <span class="comment">// class_data_bits_t 相当于是class_rw_t 指针加上rr/alloc标志</span></span><br><span class="line">    <span class="keyword">class_data_bits_t</span> bits;    <span class="comment">// class_rw_t * plus custom rr/alloc flags</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">class_rw_t</span> *<span class="title">data</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 这里的bits就是class_data_bits_t bits;</span></span><br><span class="line">        <span class="keyword">return</span> bits.data();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...还有很多的方法,我这边就不列举出来了,主要是看看里面的成员</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发现objc_class结构体实际上是继承objc_object的,然后我们再去看看objc_object</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_object</span> &#123;</span></span><br><span class="line">    <span class="comment">// isa结构体</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">isa_t</span> isa;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ISA() assumes this is NOT a tagged pointer object</span></span><br><span class="line">    <span class="function">Class <span class="title">ISA</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// getIsa() allows this to be a tagged pointer object</span></span><br><span class="line">    <span class="function">Class <span class="title">getIsa</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...等等很多其他方法,这边忽略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到objc_object的结构体里面只有一个isa,所以objc_class的结构体里面有isa、superclass、cache、bits和一个class_rw_t *data(),可以看到是直接返回的bits.data(),跟进去看下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">class_rw_t</span>* <span class="title">data</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// FAST_DATA_MASK的值是0x00007ffffffffff8UL</span></span><br><span class="line">        <span class="comment">// bits和FAST_DATA_MASK按位与，实际上就是取了bits中的[3,46]位</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">class_rw_t</span> *)(bits &amp; FAST_DATA_MASK);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可以看到就是bits和FAST_DATA_MASK进行了了一次位与运算,然后强制转成class_rw_t类型,然后我们进去看下class_rw_t的结构</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类的方法、属性、协议等信息都保存在class_rw_t结构体中</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">class_rw_t</span> &#123;</span></span><br><span class="line">    <span class="comment">// Be warned that Symbolication knows the layout of this structure.</span></span><br><span class="line">    <span class="keyword">uint32_t</span> flags;</span><br><span class="line">    <span class="keyword">uint32_t</span> version;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">class_ro_t</span> *ro;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 方法信息</span></span><br><span class="line">    <span class="keyword">method_array_t</span> methods;</span><br><span class="line">    <span class="comment">// 属性信息</span></span><br><span class="line">    <span class="keyword">property_array_t</span> properties;</span><br><span class="line">    <span class="comment">// 协议信息</span></span><br><span class="line">    <span class="keyword">protocol_array_t</span> protocols;</span><br><span class="line"></span><br><span class="line">    Class firstSubclass;</span><br><span class="line">    Class nextSiblingClass;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> *demangledName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这个里面就有方法信息、属性信息和协议信息,还有一个只读的ro表,跟踪下去可以看到</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// class_ro_t结构体存储了类在编译期就已经确定的属性、方法以及遵循的协议</span></span><br><span class="line"><span class="comment">// 因为在编译期就已经确定了，所以是ro(readonly)的，不可修改</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">class_ro_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> flags;</span><br><span class="line">    <span class="keyword">uint32_t</span> instanceStart;</span><br><span class="line">    <span class="keyword">uint32_t</span> instanceSize;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __LP64__</span></span><br><span class="line">    <span class="keyword">uint32_t</span> reserved;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint8_t</span> * ivarLayout;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> * name;</span><br><span class="line">    <span class="comment">// 方法列表</span></span><br><span class="line">    <span class="keyword">method_list_t</span> * baseMethodList;</span><br><span class="line">    <span class="comment">// 协议列表</span></span><br><span class="line">    <span class="keyword">protocol_list_t</span> * baseProtocols;</span><br><span class="line">    <span class="comment">// 变量列表</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">ivar_list_t</span> * ivars;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint8_t</span> * weakIvarLayout;</span><br><span class="line">    <span class="comment">// 属性列表</span></span><br><span class="line">    <span class="keyword">property_list_t</span> *baseProperties;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">method_list_t</span> *<span class="title">baseMethods</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> baseMethodList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以看到这个里面也有方法、协议等信息,这是因为ro表里面存储的是在编译期间就已经确定的信息,这里面的信息只可以读取不可以写入,通过这些信息整理一下,可以得到整个class的结构.<br><img src="WeChat9872c5853b4a5aab8fa5548f45bc92e2.png" alt="" title="objc_class结构图"></p><blockquote><p>Mark一篇更为详细的文章<a href="http://vanney9.com/2017/06/05/objective-c-runtime-property-method/" target="_blank" rel="noopener">Objective-C runtime - 属性与方法</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;写Blog也是一门技术啊,逻辑还是有点混乱…&lt;/p&gt;
&lt;h4 id=&quot;对象的分类&quot;&gt;&lt;a href=&quot;#对象的分类&quot; class=&quot;headerlink&quot; title=&quot;对象的分类&quot;&gt;&lt;/a&gt;对象的分类&lt;/h4&gt;&lt;p&gt;iOS对象分为以下三类&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;实例对象(instance对象)&lt;/li&gt;
&lt;li&gt;类对象(class对象)&lt;/li&gt;
&lt;li&gt;元类对象(meta-class对象)
    
    </summary>
    
    
      <category term="iOS" scheme="http://fenglee594.github.io/categories/iOS/"/>
    
    
      <category term="小马哥底层原理学习笔记" scheme="http://fenglee594.github.io/tags/%E5%B0%8F%E9%A9%AC%E5%93%A5%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Objective-C 对象的本质</title>
    <link href="http://fenglee594.github.io/2020/05/25/OC%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%9C%AC%E8%B4%A8/"/>
    <id>http://fenglee594.github.io/2020/05/25/OC%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%9C%AC%E8%B4%A8/</id>
    <published>2020-05-25T11:50:48.000Z</published>
    <updated>2020-06-10T12:23:22.889Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>其实去年年底看过一遍这个教程了,但是没有系统的记录下来很多东西都忘记了,所以这次打算重新学习一下,并且记录一些我认为的知识重点.</p><a id="more"></a><h4 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h4><h5 id="1-一个NSObject对象占用多少内存？"><a href="#1-一个NSObject对象占用多少内存？" class="headerlink" title="1. 一个NSObject对象占用多少内存？"></a>1. 一个NSObject对象占用多少内存？</h5><p>创建一个NSObject对象需要分配16个字节（通过malloc_size函数获得）,但NSObject对象内部只使用了8个字节的空间(64bit环境下，可以通过class_getInstanceSize函数获得）<br>其实通过追踪源码alloc的实现我们可以看到以下这段代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Class's ivar size rounded up to a pointer-size boundary.</span></span><br><span class="line"><span class="comment">// 返回成员变量指针大小(四舍五入)</span></span><br><span class="line"><span class="comment">//class_getInstanceSize()方法通过跟踪可以看到实际上就是调用的alignedInstanceSize()这个方法,NSObject,成员变量只有isa指针也就是8个字节</span></span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">alignedInstanceSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> word_align(unalignedInstanceSize());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">instanceSize</span><span class="params">(<span class="keyword">size_t</span> extraBytes)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> <span class="built_in">size</span> = alignedInstanceSize() + extraBytes;</span><br><span class="line">    <span class="comment">// CF requires all objects be at least 16 bytes.</span></span><br><span class="line">    <span class="comment">// Core Foundation 要求所有的对象至少要16个字节</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">size</span> &lt; <span class="number">16</span>) <span class="built_in">size</span> = <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">size</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>class_getInstanceSize()方法是获取对象至少需要占用的内存大小,在内存对齐中以8字节为基准(isa占8个字节),也就是通过class_getInstanceSize()方法获取的内存大小是8的倍数.<br>malloc_size()方法是获取系统给对象实际分配的内存大小,也会有一个对齐动作,对齐的基数是16个字节,也就是说分配的内存是16的倍数.<br><code>#define NANO_MAX_SIZE          256 /* Buckets sized {16, 32, 48, ..., 256} */</code><br>sizeof()这个其实是一个运算符,在编译期间就已经确定的,用来计算传进去的类型大小,例如sizeof(int),实际上就是计算int类型所占的内存大小也就是4个字节.</p><h5 id="2-自定义一个Student对象-怎么计算它所占的内存"><a href="#2-自定义一个Student对象-怎么计算它所占的内存" class="headerlink" title="2. 自定义一个Student对象,怎么计算它所占的内存?"></a>2. 自定义一个Student对象,怎么计算它所占的内存?</h5><p><img src="WeChat2c7ebbc20545545aed8859d5e3b0938a.png" alt="Student类的本质" title="Student类的数据结构"></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Student</span> : <span class="title">NSObject</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">@public</span></span><br><span class="line">    <span class="keyword">int</span> _no;</span><br><span class="line">    <span class="keyword">int</span> _age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这个对象的本质是一个以下的结构体</span></span><br><span class="line"><span class="keyword">struct</span> Student_IMPL &#123;</span><br><span class="line">    Class isa;  <span class="comment">//8bytes</span></span><br><span class="line">    <span class="keyword">int</span> _no;    <span class="comment">//int类型占4bytes</span></span><br><span class="line">    <span class="keyword">int</span> _age;   <span class="comment">//4 </span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//显而易见这个student对象所占内存为16个字节.</span></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><h5 id="3-需要注意的一点是iOS下的内存分配是小端模式也就是读取数据是从高地址开始读的"><a href="#3-需要注意的一点是iOS下的内存分配是小端模式也就是读取数据是从高地址开始读的" class="headerlink" title="3. 需要注意的一点是iOS下的内存分配是小端模式也就是读取数据是从高地址开始读的."></a>3. 需要注意的一点是iOS下的内存分配是<a href="https://baike.baidu.com/item/大小端模式/6750542" target="_blank" rel="noopener">小端模式</a>也就是读取数据是从高地址开始读的.</h5><ul><li>关于大小端模式我的理解<ul><li>大端模式是数据的高字节保存在内存的低地址中,低字节保存在内存的高地址中,读取数据的时候我们是从低地址-&gt;高地址</li><li>小端模式是数据高字节保存在内存的高地址中,低字节保存在内存的低地址中,读取数据的时候我们是从高地址-&gt;低地址</li><li>关于高字节和低字节我们可以举个例子.比如有个10进制数据2000,转换成16进制就是0x7d0,其中7就是高字节,0就是低字节</li><li>一般数据读取我都是习惯高字节-&gt;低字节</li></ul></li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Student *stu = [[Student alloc] init];</span><br><span class="line">stu-&gt;_no = <span class="number">4</span>;</span><br><span class="line">stu-&gt;_age = <span class="number">5</span>;</span><br></pre></td></tr></table></figure><p>以上面个实例为例,我这边调试在Xcode的view memory中(见下面的内存分配图)看到其内存分配为(从左到右从上到下是低地址到高地址)<br>C9 11 00 00 01 80 1D 00 04 00 00 00 05 00 00 00<br>stu的isa指针占8个字节,即C9 11 00 00 01 80 1D 00<br>_no 占4个字节,即04 00 00 00<br>_age占4个字节,即05 00 00 00<br>因为是小端模式读取可以看到_no就是0x00000004,_age为0x00000005<br>如果按照大端模式那就是_no:0x04000000 _age:0x05000000 这是不对的<br><img src="1590565668018.jpg" alt="内存分配图" title="内存分配图"></p><h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><ol><li>OC对象的本质是什么?<br>OC对象的本质是C/C++的结构体.<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//NSObject对象的本质就是NSObject_IMPL结构体</span></span><br><span class="line"><span class="built_in">NSObject</span> *obj = [[<span class="built_in">NSObject</span> alloc] init];</span><br><span class="line"><span class="keyword">struct</span> <span class="built_in">NSObject_IMPL</span> &#123;</span><br><span class="line">    Class isa;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Student对象的本质就是NSObject_IMPL结构体</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Student</span> : <span class="title">NSObject</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">@public</span></span><br><span class="line">    <span class="keyword">int</span> _no;</span><br><span class="line">    <span class="keyword">int</span> _age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> Student_IMPL &#123;</span><br><span class="line">    Class isa;</span><br><span class="line">    <span class="keyword">int</span> _no;</span><br><span class="line">    <span class="keyword">int</span> _age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h4><ul><li><p>将Objective-C代码转换成C/C++形式的runtime源码<br><code>xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc main.m -o main.cpp</code><br>main.m 是指OC源文件 main.cpp是指输出文件<br>如果需要链接其他框架，使用-framework参数。比如-framework UIKit</p></li><li><p><a href="https://opensource.apple.com/tarballs/objc4/" target="_blank" rel="noopener">苹果源码链接</a></p></li><li><p><a href="http://ftp.gnu.org/gnu/glibc/" target="_blank" rel="noopener">GNU的C源码链接</a></p></li><li><p>实时查看内存数据(Debug -&gt; Debug Workfllow -&gt; View Memory)</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;其实去年年底看过一遍这个教程了,但是没有系统的记录下来很多东西都忘记了,所以这次打算重新学习一下,并且记录一些我认为的知识重点.&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://fenglee594.github.io/categories/iOS/"/>
    
    
      <category term="小马哥底层原理学习笔记" scheme="http://fenglee594.github.io/tags/%E5%B0%8F%E9%A9%AC%E5%93%A5%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>2019个人总结</title>
    <link href="http://fenglee594.github.io/2020/01/07/2019%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/"/>
    <id>http://fenglee594.github.io/2020/01/07/2019%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/</id>
    <published>2020-01-07T15:12:42.000Z</published>
    <updated>2020-01-08T16:03:50.870Z</updated>
    
    <content type="html"><![CDATA[<p>之前12月底就想写,但是太懒了,还是拖到了现在(拖延症晚期患者没救了)<br>回顾这一年下来,给我的感觉是有点平淡如水加彷徨茫然,说平淡如水那是因为日子整天就这样过,上班下班睡觉,波澜不惊,但日子这样一天天过下去,也就导致了我的彷徨茫然.有时候不知道自己该干啥或者说在干些啥.回想一下,会有一种怎么这么快就又是一年过去了的感觉.这是我今年的一种大致状态吧.</p><a id="more"></a><h4 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h4><p>今年的工作整体一个感觉而言还是比较混的,感觉学到的东西不是那么多.今年苹果爸爸审核越发的严格了,从以前的4.3到现在账号调查甚至都不让申请账号了,让我越来越感觉游戏马甲包过包这一块没啥搞头了,之前不说技术上有没有啥提升,至少过一个包还能拿一拿奖金,现在过不了包奖金啥的自然是没了.技术上这一块只是做游戏SDK的话实在是没有啥东西好说的.</p><p>仔细想想,今年技术上这一块也不是完全没有收获吧.按照时间线回顾一下<br>1、年初的时候试着用Swift重写了一遍SDK工程,算是对Swift有了一个整体的了解(但是后面又没怎么用Swift,忘的差不多了,哭死).Swift给我的感觉比OC更加的友好,简洁.刚写完Swift工程的时候我甚至一度都很嫌弃OC,哈哈.<br>2、之后给我印象比较深的一个就是那个渠道包的原生游戏链接要加参数的事情了,这个让我学到更深一点的网络的东西,关于NSURLProtocol拦截网络请求、Get、Post等等网络相关的编程知识<br>3、在7、8月份的时候其实有想过离职,所以在这段时间里有去准备一些面试的东西,最有收获的是买了一套小马哥的底层原理视频,系统的学习了一下iOS原理的一些东西,比如消息转发机制、Runloop、Runtime、Block、KVC/KVO的原理和多线程的一些知识,把很多以前只听过概念,没去了解的东西了解了一下,收获还是很多的,这个也一直还在看,还没看完,目前看到了多线程相关的知识<br>4、中间还利用正则写过简单的爬虫爬小说,也爬过网易新闻然后弄了个小的新闻app,也挺有意思的.之前一直以为爬虫是很玄奥的东西,然后自己弄了之后才发现爬虫是怎么回事,爬虫并不需要指定特别的编程语言才能写.大部分人使用Python去写,是因为Python里面有很多爬虫的库可以直接拿来使用,如果只是简单的一些小爬虫,完全可以用其他语言去写,比如我就是用的OC.<br>5、最近老大让去用SwiftUI重写一套SDK,所以在看这个.给我的感觉是很不习惯的用法(可能是OC的毒害太深了),其实明显感觉跟网页的布局很有相似之处,画盒子那样.要加把劲,把这东西弄出来了.</p><p>除了这些,从其他渠道获取的一些信息,让我明显感觉iOS开发越来越会偏向于Swift开发了,所以Swift在接下来会是我一个学习和使用的重点.</p><h4 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h4><p>2019年的生活,过的不算如意,但也不算太烂.</p><p>年初回来我换了房子,住进了小区,但是因为自己没有仔细看房导致住进去之后发现很多不太理想的地方,有一点比较难受是阳台晒不到太阳,被子、鞋都没地方晾.从这次租房我学到了做事不要心血来潮,要有规划.不管租房还是买东西都要货比三家.还有一点就是不要跟女生合租.<br>今年下半年倒是把乒乓球捡起来打了一下,没有固定的队友打着确实也没读书那会儿的感觉了.然后很多周末倒是宅在宿舍里了,这一点不太好.<br>关于健身,今年去报了一个私教,练了一个月没啥效果,后面也就没去练了,后来自己在家买了哑铃跟着keep练,效果不明显.在朋友的推荐下去买了增肌粉,但是发现喝着会导致便秘,有点难受.不过接下来还得练,毕竟增肌粉也好几百块钱呢,得喝完,哈哈.体重倒是一直没增,离年初胖10斤的目标还是那么远.</p><h4 id="理财"><a href="#理财" class="headerlink" title="理财"></a>理财</h4><p>去年年底,我把股票清仓了,导致错过年初一波大行情.在回来之后又陆陆续续买了几万块的股票.今年整体行情还是很不错的,毕竟18年因为中美贸易战的关系,A股一直跌.但是因为我踩雷康美药业的原因导致今年收益大概是亏了10K左右,就当交学费了吧.</p><p>总结一下就是买股票还是要买价值股,买股票毕竟也是一种价值投资.<br>如果只是因为A股大环境下而下跌的蓝筹股,完全可以越跌越买,拿长线,比如格力、美的、京东方等等.我今年亏这么多,很大一部分原因就是容易慌,比如索菲亚、三七互娱、中信建投这几个是最可惜的,都是跌的底的时候割肉出了,结果都反弹了涨疯了.<br>还有就是要了解时事,对市场反应要快,比如最近的中东局势导致黄金原油暴涨.这种新闻出来完全可以买入一些黄金石油炒短线的,但是不能贪,看局势发展,然后决定是继续持有还是卖出.<br>另外还有基金,这个其实可以占据理财资金里面比较大的一部分,大部分拿去买一些指数基金,然后适当的配置一些消费板块、市场反应火热的一些板块.<br>说到底,股票就是不能贪,但是不能慌,多买一些知名的优质股,拿长线.基金就是买指数,定投都可以.理财不能把所有的资金都投进去,要留一部分流动资金备用.</p><p>看起来2020年的市场行情会很不错,如果中美贸易战不起大的波澜或者全球局势不发生大的动荡的情况下,2020的股市还是很令人期待的,希望不会又是交学费的一年.</p><h4 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h4><p>最重要的还是提升自己,编程技术.至少3本技术相关书籍.<br>等过完年回来要提离职了,现在的工作让我感觉没有提升的空间.<br>关于技术方向我是想往音视频这一块去发展的,希望到时候找工作能找到.<br>找工作希望能进大一点的公司,投简历的话打算投一下网易、酷狗、YY、Bigo等大一点的互联网公司,希望能有机会进去.加油.<br>非技术类书籍,至少读四本吧.<br>健身增肌,目标10斤.</p><p>有机会的话找个女朋友😄</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前12月底就想写,但是太懒了,还是拖到了现在(拖延症晚期患者没救了)&lt;br&gt;回顾这一年下来,给我的感觉是有点平淡如水加彷徨茫然,说平淡如水那是因为日子整天就这样过,上班下班睡觉,波澜不惊,但日子这样一天天过下去,也就导致了我的彷徨茫然.有时候不知道自己该干啥或者说在干些啥.回想一下,会有一种怎么这么快就又是一年过去了的感觉.这是我今年的一种大致状态吧.&lt;/p&gt;
    
    </summary>
    
    
      <category term="年终总结" scheme="http://fenglee594.github.io/categories/%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="一年回顾" scheme="http://fenglee594.github.io/tags/%E4%B8%80%E5%B9%B4%E5%9B%9E%E9%A1%BE/"/>
    
  </entry>
  
  <entry>
    <title>iOS拦截(包括但不限于)WKWebView的Http、Https网络请求</title>
    <link href="http://fenglee594.github.io/2019/12/22/iOS%E6%8B%A6%E6%88%AA%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82/"/>
    <id>http://fenglee594.github.io/2019/12/22/iOS%E6%8B%A6%E6%88%AA%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82/</id>
    <published>2019-12-22T05:06:07.000Z</published>
    <updated>2020-05-27T09:24:09.568Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>最近手上有个需求,需要在一条网络请求上加上两个参数,按道理说直接在URL后面加上&amp;xx=xxx就行了,但是因为各种原因,我只能把所有的网络请求拦截下来,然后找到我想要的那条请求,重新处理完之后再去请求.</p><a id="more"></a><h4 id="了解NSURLProtocol"><a href="#了解NSURLProtocol" class="headerlink" title="了解NSURLProtocol"></a>了解NSURLProtocol</h4><p>通过网上找资料发现我的需求可以通过NSURLProtocol来实现,而我们的请求基本都是通过一个叫做<a href="https://developer.apple.com/documentation/foundation/url_loading_system?language=objc" target="_blank" rel="noopener">URL Loading System</a>的东西来实现的,socket通信除外.来看一下URL Loading System的关系图<br><img src="2257417.jpg" alt="URL Loading System"></p><p>可以看到URL Loading System包含了网络请求类、网络验证类、URLSession初始化管理、以及我们需要的NSURLProtocol.<br>NSURLProtocol是一个处理URL数据加载的特殊协议类(抽象类),我们不能直接用它去实例化一个对象,而是要继承他去创建一个子类,并且在合适的时机去注册它,利用它我们可以重新自定义URL加载系统,具体来说利用它我们可以做的事情包括但不限于以下几种</p><ul><li>修改请求头</li><li>修改请求的URL(加参数、重定向)</li><li>解决一些DNS被劫持的问题(使用ip直接访问)</li><li>拦截网络请求,做一些埋点</li><li>按我们自己的意愿缓存资源</li></ul><h4 id="Demo内容"><a href="#Demo内容" class="headerlink" title="Demo内容"></a>Demo内容</h4><p>我打算写一个简单demo,在主页面上有一个控制是否拦截请求的开关,没有打开的时候,点击百度和网易的按钮都是正常访问相应的网址,打开之后点击跳转百度会重定向到腾讯新闻,点击网易会重定向到新浪新闻,具体代码看Demo</p><h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><pre><code>1、创建继承NSURLProtocol的子类CustomURLProtocol.2、重写NSURLProtocol的方法,拦截并转发修改后的请求.3、注册CustomURLProtocol.</code></pre><h5 id="创建CustomURLProtocol必须实现的几个方法"><a href="#创建CustomURLProtocol必须实现的几个方法" class="headerlink" title="创建CustomURLProtocol必须实现的几个方法"></a>创建CustomURLProtocol必须实现的几个方法</h5><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="built_in">BOOL</span>)canInitWithRequest:(<span class="built_in">NSURLRequest</span> *)request;</span><br><span class="line">+ (<span class="built_in">NSURLRequest</span> *)canonicalRequestForRequest:(<span class="built_in">NSURLRequest</span> *)request;</span><br><span class="line">+ (<span class="built_in">BOOL</span>)requestIsCacheEquivalent:(<span class="built_in">NSURLRequest</span> *)a toRequest:(<span class="built_in">NSURLRequest</span> *)b;</span><br><span class="line">- (<span class="keyword">void</span>)startLoading;</span><br><span class="line">- (<span class="keyword">void</span>)stopLoading;</span><br></pre></td></tr></table></figure><p>1、重写方法canInitWithRequest:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 判断是不是需要hook请求,return yes就hook,然后处理转发,no就放行,不用我们进行处理.</span></span><br><span class="line"><span class="comment"> 这里有个需要注意的地方,正常流程是我们hook了这个请求,然后在startLoading中完成我们需要的操作,再通过URLSession转发出去这个时候我们需要给请求加一个属性来判断是否已经进行了处理,不然的话,流程就会变成拦截--&gt;处理--&gt;转发--&gt;拦截,陷入死循环.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">+ (<span class="built_in">BOOL</span>)canInitWithRequest:(<span class="built_in">NSURLRequest</span> *)request</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//    NSLog(@"%s: %@",__func__, request.URL.absoluteString);</span></span><br><span class="line">    <span class="built_in">NSString</span> *scheme = [[request URL] scheme];</span><br><span class="line">    <span class="keyword">if</span> ([scheme caseInsensitiveCompare: <span class="string">@"http"</span>] == <span class="built_in">NSOrderedSame</span> || [scheme caseInsensitiveCompare:<span class="string">@"https"</span>] == <span class="built_in">NSOrderedSame</span>) &#123;</span><br><span class="line">        <span class="comment">//o判断是否已经处理过</span></span><br><span class="line">        <span class="keyword">if</span> ([<span class="built_in">NSURLProtocol</span> propertyForKey:kURLProtocolHandledKey inRequest:request]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、重写方法canonicalRequestForRequest</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">+ (<span class="built_in">NSURLRequest</span> *) canonicalRequestForRequest:(<span class="built_in">NSURLRequest</span> *)request &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSMutableURLRequest</span> *mutableReqeust = [request mutableCopy];</span><br><span class="line">    <span class="comment">// 可以在这里添加request的header,如果不做操作直接return request也可以</span></span><br><span class="line">    <span class="keyword">return</span> mutableReqeust;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、重写方法requestIsCacheEquivalent:toRequest:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">+ (<span class="built_in">BOOL</span>)requestIsCacheEquivalent:(<span class="built_in">NSURLRequest</span> *)a toRequest:(<span class="built_in">NSURLRequest</span> *)b</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//啥都不做直接扔给系统</span></span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> requestIsCacheEquivalent:a toRequest:b];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、重新方法startLoading:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)startLoading</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//    NSLog(@"%s: %@",__func__, self.request.URL.absoluteString);</span></span><br><span class="line">    <span class="built_in">NSMutableURLRequest</span> *request = [[<span class="keyword">self</span> request] mutableCopy];</span><br><span class="line">    <span class="comment">// 标示改request已经处理过了，防止无限循环</span></span><br><span class="line">    [<span class="built_in">NSURLProtocol</span> setProperty:@(<span class="literal">YES</span>) forKey:HookPropertyKey inRequest:request];</span><br><span class="line">    <span class="keyword">if</span> ([request.URL.absoluteString isEqualToString:<span class="string">@"https://www.baidu.com/"</span>]) &#123;</span><br><span class="line">        request.URL = [<span class="built_in">NSURL</span> URLWithString:<span class="string">@"https://news.qq.com"</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ([request.URL.absoluteString containsString:<span class="string">@"https://www.163.com/"</span>]) &#123;</span><br><span class="line">        request.URL = [<span class="built_in">NSURL</span> URLWithString:<span class="string">@"https://news.sina.com.cn"</span>]; <span class="comment">//跳转网易</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">self</span> requestData:request];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5、重写方法stopLoading</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)stopLoading</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">self</span>.task cancel];</span><br><span class="line">    <span class="keyword">self</span>.session = <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到上面这一步我们对拦截请求的功能实现完了,但是我们还需要利用session将处理后的请求转发出去,相当于把session请求到的response又交给了原来的webview去处理,代码如下:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session task:(<span class="built_in">NSURLSessionTask</span> *)task didCompleteWithError:(<span class="built_in">NSError</span> *)error</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (error != <span class="literal">nil</span>) &#123;</span><br><span class="line">        [<span class="keyword">self</span>.client URLProtocol:<span class="keyword">self</span> didFailWithError:error];</span><br><span class="line">    &#125;<span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        [<span class="keyword">self</span>.client URLProtocolDidFinishLoading:<span class="keyword">self</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session dataTask:(<span class="built_in">NSURLSessionDataTask</span> *)dataTask</span><br><span class="line">didReceiveResponse:(<span class="built_in">NSURLResponse</span> *)response</span><br><span class="line"> completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">NSURLSessionResponseDisposition</span> disposition))completionHandler</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">self</span>.client URLProtocol:<span class="keyword">self</span> didReceiveResponse:response cacheStoragePolicy:<span class="built_in">NSURLCacheStorageNotAllowed</span>];</span><br><span class="line"></span><br><span class="line">    completionHandler(<span class="built_in">NSURLSessionResponseAllow</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session dataTask:(<span class="built_in">NSURLSessionDataTask</span> *)dataTask didReceiveData:(<span class="built_in">NSData</span> *)data</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">self</span>.client URLProtocol:<span class="keyword">self</span> didLoadData:data];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session dataTask:(<span class="built_in">NSURLSessionDataTask</span> *)dataTask willCacheResponse:(<span class="built_in">NSCachedURLResponse</span> *)proposedResponse completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">NSCachedURLResponse</span> * _Nullable))completionHandler</span><br><span class="line">&#123;</span><br><span class="line">    completionHandler(proposedResponse);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="注册CustomURLProtocol"><a href="#注册CustomURLProtocol" class="headerlink" title="注册CustomURLProtocol"></a>注册CustomURLProtocol</h5><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>) registerClass</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSString</span> *className = <span class="string">@"WKBrowsingContextController"</span>;</span><br><span class="line">    Class cls = <span class="built_in">NSClassFromString</span>(className);</span><br><span class="line">    SEL sel = <span class="built_in">NSSelectorFromString</span>(<span class="string">@"registerSchemeForCustomProtocol:"</span>);</span><br><span class="line">    <span class="keyword">if</span> ([cls respondsToSelector:sel]) &#123;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">pragma</span> clang diagnostic push</span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">pragma</span> clang diagnostic ignored <span class="meta-string">"-Warc-performSelector-leaks"</span></span></span><br><span class="line">        [cls performSelector:sel withObject:<span class="string">@"http"</span>];</span><br><span class="line">        [cls performSelector:sel withObject:<span class="string">@"https"</span>];</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">pragma</span> clang diagnostic pop</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    [<span class="built_in">NSURLProtocol</span> registerClass:[CustomURLProtocol <span class="keyword">class</span>]];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注册了之后URLProtocol会拦截所有的请求,当你拦截完你某些想要的请求后,不再拦截也是可以的,这时候我们可以注销掉CustomURLProtocol</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>) unregisterClass</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//注销</span></span><br><span class="line">    [<span class="built_in">NSURLProtocol</span> unregisterClass:[CustomURLProtocol <span class="keyword">class</span>]];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>1、一个是要注意给已经处理过的请求一个标识,告诉CustomURLProcol这个请求我已经处理过了,不需要再次处理了,不然的话会一直循环处理,因为你把处理完的请求转发出去了,相当于又一次请求了你处理完的URL,自然就会被我们的CustomURLProtocol拦截到,你不给标识的话就会导致一直循环,请求自然就无法完成了.具体可以看canInitWithRequest:和startLoading方法里面的处理.<br>2、上面这些可以hook所有的包括get和post请求,但是post请求会存在数据丢失的问题存在,这个问题又分为两种情况,一种是正常的session post请求(包括AFNetworking),还有一种是wkwebview中夹在的post请求,在这里我的解决方案是在加载wkwebview的时候我注入了script文件夹中的js去hook了ajax的请求,把body数据存储到了本地(NSUserDefaults存储,key为请求的url, value为body数据),在需要的时候再把body数据拿出来,操作都在以下method中,具体看代码:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">-(<span class="keyword">void</span>) requestData:(<span class="built_in">NSMutableURLRequest</span> *) request &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSInputStream</span> *bodyStream = [request HTTPBodyStream];</span><br><span class="line">    [bodyStream open];</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     一般的post请求在这边使用这个判断加操作就可以拿到body的数据,但是因为wkwebview在post请求的时候会自动丢掉body,</span></span><br><span class="line"><span class="comment">     所以我们才需要script文件夹中的脚本去hook wkwebview的body数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//判断body里面是不是有数据,有数据就copy一份出来</span></span><br><span class="line">    <span class="keyword">if</span> ([bodyStream hasBytesAvailable]) &#123;</span><br><span class="line">        <span class="built_in">NSMutableData</span> *data = [[<span class="built_in">NSMutableData</span> alloc] init];</span><br><span class="line">        uint8_t buffer[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">while</span> ([bodyStream hasBytesAvailable]) &#123;</span><br><span class="line">            <span class="built_in">NSInteger</span> len = [bodyStream read:buffer maxLength:<span class="number">1024</span>];</span><br><span class="line">            <span class="keyword">if</span> (len &gt; <span class="number">0</span> &amp;&amp; bodyStream.streamError == <span class="literal">nil</span>) &#123;</span><br><span class="line">                [data appendBytes:(<span class="keyword">void</span> *)buffer length:len];</span><br><span class="line">            &#125;</span><br><span class="line">            memset(buffer, <span class="number">0</span>, <span class="number">1024</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        request.HTTPBody = [data <span class="keyword">copy</span>];</span><br><span class="line">        [bodyStream close];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//body里面没有数据就去我们之前的缓存里面那数据</span></span><br><span class="line">        <span class="built_in">NSString</span> *key = [[[request URL] absoluteString] lowercaseString];</span><br><span class="line">        <span class="built_in">NSString</span> *data = [[<span class="built_in">NSUserDefaults</span> standardUserDefaults] objectForKey:key];</span><br><span class="line">        [[<span class="built_in">NSUserDefaults</span> standardUserDefaults] synchronize];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (data != <span class="literal">nil</span>) &#123;<span class="comment">//缓存有数据</span></span><br><span class="line">            <span class="built_in">NSDictionary</span> *dataJson = [<span class="built_in">NSJSONSerialization</span> JSONObjectWithData: [data dataUsingEncoding:<span class="built_in">NSUTF8StringEncoding</span>] options:<span class="number">0</span> error:<span class="literal">nil</span>];</span><br><span class="line">            <span class="keyword">if</span> (dataJson != <span class="literal">nil</span>) &#123;</span><br><span class="line">                [request setHTTPBody: [<span class="built_in">NSJSONSerialization</span> dataWithJSONObject:dataJson options:<span class="number">0</span> error:<span class="literal">nil</span>]];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                [request setHTTPBody: [data dataUsingEncoding:<span class="built_in">NSUTF8StringEncoding</span>]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">NSURLSessionConfiguration</span> *configure = [<span class="built_in">NSURLSessionConfiguration</span> defaultSessionConfiguration];</span><br><span class="line">    <span class="keyword">self</span>.session  = [<span class="built_in">NSURLSession</span> sessionWithConfiguration:configure delegate:<span class="keyword">self</span> delegateQueue:[<span class="built_in">NSOperationQueue</span> new]];</span><br><span class="line">    <span class="keyword">self</span>.task = [<span class="keyword">self</span>.session dataTaskWithRequest:request];</span><br><span class="line">    [<span class="keyword">self</span>.task resume];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>脚本文件如图<br><img src="1576990382190.jpg" alt="脚本文件"><br>js注入的代码</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">WKWebViewConfiguration</span> *config = [<span class="built_in">WKWebViewConfiguration</span> new];</span><br><span class="line"></span><br><span class="line"> <span class="comment">//将js脚本注入,然后通过WebViewPostHandler方法拿到从网页端发送过来的数据</span></span><br><span class="line"><span class="built_in">NSString</span> *jspath = [[<span class="built_in">NSBundle</span> mainBundle] pathForResource:<span class="string">@"ajaxhook.min.js"</span> ofType:<span class="literal">nil</span>];</span><br><span class="line"><span class="built_in">NSString</span> *ajaxhook = [<span class="built_in">NSString</span> stringWithContentsOfFile:jspath encoding:<span class="built_in">NSUTF8StringEncoding</span> error:<span class="literal">nil</span>];</span><br><span class="line"><span class="built_in">WKUserScript</span> *sc = [[<span class="built_in">WKUserScript</span> alloc] initWithSource:ajaxhook injectionTime:<span class="built_in">WKUserScriptInjectionTimeAtDocumentStart</span> forMainFrameOnly:<span class="literal">NO</span>];</span><br><span class="line">[[config userContentController] addUserScript:sc];</span><br><span class="line"></span><br><span class="line">jspath = [[<span class="built_in">NSBundle</span> mainBundle] pathForResource:<span class="string">@"jquery.min.js"</span> ofType:<span class="literal">nil</span>];</span><br><span class="line"><span class="built_in">NSString</span> *jquery = [<span class="built_in">NSString</span> stringWithContentsOfFile:jspath encoding:<span class="built_in">NSUTF8StringEncoding</span> error:<span class="literal">nil</span>];</span><br><span class="line"><span class="built_in">WKUserScript</span> *jqsc = [[<span class="built_in">WKUserScript</span> alloc] initWithSource:jquery injectionTime:<span class="built_in">WKUserScriptInjectionTimeAtDocumentStart</span> forMainFrameOnly:<span class="literal">NO</span>];</span><br><span class="line">[[config userContentController] addUserScript:jqsc];</span><br><span class="line"></span><br><span class="line">jspath = [[<span class="built_in">NSBundle</span> mainBundle] pathForResource:<span class="string">@"xhrhook.js"</span> ofType:<span class="literal">nil</span>];</span><br><span class="line"><span class="built_in">NSString</span> *xhrhook = [<span class="built_in">NSString</span> stringWithContentsOfFile:jspath encoding:<span class="built_in">NSUTF8StringEncoding</span> error:<span class="literal">nil</span>];</span><br><span class="line"><span class="built_in">WKUserScript</span> *xhrhooksc = [[<span class="built_in">WKUserScript</span> alloc] initWithSource:xhrhook injectionTime:<span class="built_in">WKUserScriptInjectionTimeAtDocumentStart</span> forMainFrameOnly:<span class="literal">NO</span>];</span><br><span class="line">[[config userContentController] addUserScript:xhrhooksc];</span><br><span class="line"></span><br><span class="line">WebViewPostHandler *postHandler = [WebViewPostHandler new];</span><br><span class="line">[[config userContentController] addScriptMessageHandler:postHandler name:<span class="string">@"save"</span>];</span><br></pre></td></tr></table></figure><p>我这边是利用WebViewPostHandler接收从web端发送过来的数据,然后保存下来了,具体看Demo吧,代码放太多了,看得有点晕.</p><h4 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h4><p>效果图<br><img src="hookRequest.gif" alt="HookRequest"><br>最后奉上<a href="https://github.com/fenglee594/WKWebViewRequestHook.git" target="_blank" rel="noopener">Demo传送门</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;最近手上有个需求,需要在一条网络请求上加上两个参数,按道理说直接在URL后面加上&amp;amp;xx=xxx就行了,但是因为各种原因,我只能把所有的网络请求拦截下来,然后找到我想要的那条请求,重新处理完之后再去请求.&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://fenglee594.github.io/categories/iOS/"/>
    
    
      <category term="WKWebview" scheme="http://fenglee594.github.io/tags/WKWebview/"/>
    
      <category term="网络编程" scheme="http://fenglee594.github.io/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>iOS-WKWebView与JS交互</title>
    <link href="http://fenglee594.github.io/2019/03/11/iOS-WKWebView%E4%B8%8EJS%E4%BA%A4%E4%BA%92/"/>
    <id>http://fenglee594.github.io/2019/03/11/iOS-WKWebView%E4%B8%8EJS%E4%BA%A4%E4%BA%92/</id>
    <published>2019-03-11T09:11:40.000Z</published>
    <updated>2019-07-09T11:53:43.887Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>现在很多app都会使用一些h5页面来代替一些要求灵活性的页面,这时候肯定会涉及到一些wkwebview和js交互的问题,写了个小demo以便更好的理解和记住知识点.</p><a id="more"></a><h4 id="该例子思路"><a href="#该例子思路" class="headerlink" title="该例子思路"></a>该例子思路</h4><p>通过利用一个简单的弹窗效果展示从H5端利用js发送的数据,和改变H5页面的文字测试iOS调用js的效果从而达到交互的目的</p><h4 id="WKWebView与js的交互"><a href="#WKWebView与js的交互" class="headerlink" title="WKWebView与js的交互"></a>WKWebView与js的交互</h4><h5 id="JS调用OC"><a href="#JS调用OC" class="headerlink" title="JS调用OC"></a>JS调用OC</h5><p>JS调用OC,我们首先需要了解的就是WKScriptMessageHandler,我们通过遵循了这个协议的类来获取网页端传过来的数据</p><h6 id="WKScriptMessageHandler"><a href="#WKScriptMessageHandler" class="headerlink" title="WKScriptMessageHandler"></a>WKScriptMessageHandler</h6><p>关于WKScriptMessageHandler,我们先看看官方文档的说明</p><blockquote><p>A class conforming to the WKScriptMessageHandler protocol provides a method for receiving messages from JavaScript running in a webpage.<br>翻译一下就是:WKScriptMessageHandler协议为遵循它的类提供了一个方法来接收在网页端运行的js中的消息.<br>    - (void)userContentController:(WKUserContentController *)userContentController didReceiveScriptMessage:(WKScriptMessage *)message;//就是该方法</p></blockquote><p>首先我们要新建一个类遵循WKScriptMessageHandler的协议,并实现上面的那个方法,代码如下</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">DSLFGameWebHandler</span> : <span class="title">NSObject</span> &lt;<span class="title">WKScriptMessageHandler</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">DSLFGameWebHandler</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)userContentController:(<span class="built_in">WKUserContentController</span> *)userContentController didReceiveScriptMessage:(<span class="built_in">WKScriptMessage</span> *)message&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSString</span> *info = message.body; <span class="comment">//网页端传过来的数据在body里面,如果是json数据在这里就需要将其序列化,转成我们想要的格式</span></span><br><span class="line">    [[[<span class="built_in">UIAlertView</span> alloc] initWithTitle:<span class="string">@"测试"</span> message:[<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"js调用了oc方法,传过来的数据为:%@"</span>,info] delegate:<span class="literal">nil</span> cancelButtonTitle:<span class="string">@"好的"</span> otherButtonTitles:<span class="literal">nil</span>, <span class="literal">nil</span>] show];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>怎么利用WKScriptMessageHandler去监听呢?在初始化wkwebview的时候配置一下configuration就可以了,不过需要跟网页端设定一个通用的<label style="color: red">名字</label>,如下代码设定的就是<label style="color: red">DSLFTest</label>:<br>iOS端配置代码</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">WKWebViewConfiguration</span> *configuration = [<span class="built_in">WKWebViewConfiguration</span> new];</span><br><span class="line">[configuration.userContentController addScriptMessageHandler:_webHandler name:<span class="string">@"DSLFTest"</span>];</span><br><span class="line">_webView = [[<span class="built_in">WKWebView</span> alloc] initWithFrame:<span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="built_in">UIScreen</span>.mainScreen.bounds.size.width, <span class="built_in">UIScreen</span>.mainScreen.bounds.size.height) configuration:configuration];</span><br></pre></td></tr></table></figure><p>H5端往iOS端发送数据</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">h5ButtonClicked</span>(<span class="params"></span>) </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//js调用OC</span></span><br><span class="line">    <span class="built_in">window</span>.webkit.messageHandlers.DSLFTest.postMessage(<span class="string">'你好啊'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="OC调用JS方法"><a href="#OC调用JS方法" class="headerlink" title="OC调用JS方法"></a>OC调用JS方法</h5><p>相对而言,这个比较简单,可以直接通过wkwebview的一个方法就可以实现了,代码如下</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//iOS端调用代码</span></span><br><span class="line">- (<span class="keyword">void</span>)webView:(<span class="built_in">WKWebView</span> *)webView didFinishNavigation:(<span class="built_in">WKNavigation</span> *)navigation</span><br><span class="line">&#123;   <span class="comment">//再webview加载完成的时候调用了ocTransferJs的方法,其中单引号的文字是js方法中的参数</span></span><br><span class="line">    [_webView evaluateJavaScript:<span class="string">@"ocTransferJs('oc调用js')"</span> completionHandler:^(<span class="keyword">id</span> _Nullable da, <span class="built_in">NSError</span> * _Nullable error) &#123;</span><br><span class="line">        <span class="keyword">if</span> (error != <span class="literal">nil</span>) &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,[error localizedDescription]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//H5页面中的js方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ocTransferJs</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//oc调用js</span></span><br><span class="line">    <span class="comment">//改变div1的文字</span></span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">"div1"</span>).innerHTML=a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//原本div1元素的文字</span></span><br><span class="line">&lt;div id=<span class="string">"div1"</span> style=<span class="string">"height: 30px;text-align: center;top: 200px;font-size: 30pt;"</span>&gt;这是一个测试文件&lt;<span class="regexp">/div&gt;</span></span><br></pre></td></tr></table></figure><h4 id="demo效果展示"><a href="#demo效果展示" class="headerlink" title="demo效果展示"></a>demo效果展示</h4><p><img src="demo_2019_03_11.jpg" alt=""></p><h5 id="代码传送"><a href="#代码传送" class="headerlink" title="代码传送"></a>代码传送</h5><p><a href="https://github.com/fenglee594/iOS-WKWebview-Demo.git" target="_blank" rel="noopener">GitHub地址</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;现在很多app都会使用一些h5页面来代替一些要求灵活性的页面,这时候肯定会涉及到一些wkwebview和js交互的问题,写了个小demo以便更好的理解和记住知识点.&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://fenglee594.github.io/categories/iOS/"/>
    
    
      <category term="wkwebview" scheme="http://fenglee594.github.io/tags/wkwebview/"/>
    
      <category term="笔记" scheme="http://fenglee594.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>真滴烦</title>
    <link href="http://fenglee594.github.io/2019/03/05/%E7%9C%9F%E6%BB%B4%E7%83%A6/"/>
    <id>http://fenglee594.github.io/2019/03/05/%E7%9C%9F%E6%BB%B4%E7%83%A6/</id>
    <published>2019-03-05T08:45:42.000Z</published>
    <updated>2019-03-05T09:22:16.855Z</updated>
    
    <content type="html"><![CDATA[<p>上周去租了个小区房,原本预算是1500左右结果租了一个1700+水电费的房,租完回去就后悔了.然后想着转租,真的麻烦.其实那个房子还不错啦,实在不行我就自己住进去了.</p><a id="more"></a><p>最近工作上也比较闲,没什么事情做.感觉又回到之前那家公司的感觉,没事做其实挺可怕的,感觉上班都在浪费时间,然后就想着趁着这段时间,把自己技术提高一下吧,感觉很多原理性的东西都没搞懂,再系统把OC过一遍,以后发展往音视频开发那一块感觉比较好.写游戏sdk和过马甲包感觉没啥上升空间,游戏sdk写来写去就是那两个控件,还要自己去想布局,脑袋疼.马甲包更是没搞头了,苹果爸爸近期开启了双重认证,导致再也不能像以前那样,换账号提包了.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上周去租了个小区房,原本预算是1500左右结果租了一个1700+水电费的房,租完回去就后悔了.然后想着转租,真的麻烦.其实那个房子还不错啦,实在不行我就自己住进去了.&lt;/p&gt;
    
    </summary>
    
    
      <category term="随便写写" scheme="http://fenglee594.github.io/categories/%E9%9A%8F%E4%BE%BF%E5%86%99%E5%86%99/"/>
    
    
      <category term="烦" scheme="http://fenglee594.github.io/tags/%E7%83%A6/"/>
    
  </entry>
  
</feed>
